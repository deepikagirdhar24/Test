Scenario Outline: Verify the Post Work Request API with invalid data - <Comments>
  Given Send Request to get Authentication Token for ICOS
  When I generate the JWT Token
  Then Send Request to create Work Request with below details
    | bpId        | <bpId>        |
    | type        | <type>        |
    | dueDate     | <dueDate>     |
    | subject     | <subject>     |
    | description | <description> |
  And I verify the Status Code for Work Request "<statusCode>"
  And I verify the error response for Work Request with below details
    | description   | <errDescription> |
    | error message | <error>          |
    | detail        | <detail>         |

Examples:
  | bpId      | type       | dueDate | subject | description  | statusCode | errDescription    | error                     | detail                            | Comments                                |
  | 123       | pay_domq   | 123456  | Subject | Description  | 400        |                    |                           | A validation error has occurred  | Invalid date only                       |
  | ?         | xxx        | FUTURE  | Subject | Description  | 400        | Validation Errors  | BP not found,Type invalid |                                  | Invalid bpId and type                  |
  | ?         | pay_domq   | 123456  | Subject | Description  | 400        | Validation Errors  | BP not found              | A validation error has occurred  | Invalid bpId and invalid date both     |

@And("I verify the error response for Work Request with below details")
public void iVerifyTheErrorResponseforWorkRequestWithDetails(DataTable dataTable) throws Exception {
    Map<String, String> mapResponsedata = dataTable.asMap(String.class, String.class);

    if (mapResponsedata.containsKey("description") && mapResponsedata.containsKey("error message")
            && !(mapResponsedata.get("description") == null || mapResponsedata.get("description").isEmpty())) {

        // Validation error structure (400)
        String strExpDescription = mapResponsedata.get("description");
        String strExpErrorMessages = mapResponsedata.get("error message");

        String strActualDescription = JsonHelper.extractStringField(response, "description");
        ExtentCucumberAdapter.addTestStepLog("Actual description: " + strActualDescription);
        Assert.assertEquals(strActualDescription, strExpDescription, "Mismatch in description");

        // Handle multiple error messages
        String[] strArrExpErrors = strExpErrorMessages.split("\\s*,\\s*");
        List<String> lstStrActualErrors = JsonHelper.extractListOfStringFieldsFromArray(response, "validationErrors", "error");

        ExtentCucumberAdapter.addTestStepLog("Actual error messages: " + lstStrActualErrors.toString());

        for (String strExpectedError : strArrExpErrors) {
            Assert.assertTrue(lstStrActualErrors.contains(strExpectedError),
                    "Expected error message not found: " + strExpectedError);
        }

    } else if (mapResponsedata.containsKey("detail")) {
        // NEW BLOCK: Handles generic validation response
        String expectedDetail = mapResponsedata.get("detail");
        String actualDetail = JsonHelper.extractStringField(response, "detail");
        ExtentCucumberAdapter.addTestStepLog("Actual detail: " + actualDetail);
        Assert.assertEquals(actualDetail, expectedDetail, "Mismatch in detail field");

    } else if (mapResponsedata.containsKey("error message")) {
        // Simple error response (500 or others)
        String strExpError = mapResponsedata.get("error message");
        String strActualError = JsonHelper.extractStringField(response, "error");
        ExtentCucumberAdapter.addTestStepLog("Actual error: " + strActualError);
        Assert.assertEquals(strActualError, strExpError, "Mismatch in error message");

    } else {
        throw new IllegalArgumentException("Unsupported error format in DataTable");
    }
}
