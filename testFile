These all methods I have in payload helper - 

package utilities;

import ICOS.pojo.POJODebitCardRequest;
import ICOS.pojo.POJOMoneyAccountRequest;
import ICOS.pojo.POJONewDocumentRequest;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;

public class PayloadHelper {

    private final Random random = new Random();

    public String normalize(String value) {
        if (value == null) return "";
        switch (value.trim().toUpperCase()) {
            case "NA": return null;
            case "EMPTY": return "";
            default: return value;
        }
    }

//    public String resolveDueDate(String dueDateInput) {
//        if (dueDateInput == null || dueDateInput.trim().isEmpty()) return "";
//        switch (dueDateInput.trim().toUpperCase()) {
//            case "NA": return null;
//            case "EMPTY": return "";
//            case "FUTURE": return LocalDate.now().plusDays(7).toString();
//            case "PAST": return LocalDate.now().minusDays(7).toString();
//            case "TODAY": return LocalDate.now().toString();
//            default: return dueDateInput;
//        }
//    }

    public String resolveDynamicText(String type) {
        if (type == null || type.isEmpty()) return "";

        // Handle expression like "prefix + RANDOM_6 + suffix"
        if (type.contains("+")) {
            String[] parts = type.split("\\+");
            StringBuilder result = new StringBuilder();
            for (String part : parts) {
                String trimmed = part.trim();
                result.append(resolveDynamicText(trimmed));
            }
            return result.toString();
        }

        switch (type.trim().toUpperCase()) {
            case "EMPTY":
                return "";
            case "NA":
                return null;
            case "RANDOM_LT_250":
                return randomString(random.nextInt(249) + 1);
            case "RANDOM_GT_250":
                return randomString(random.nextInt(500) + 251);
            default:
                // Check if it's like RANDOM_6
                if (type.toUpperCase().startsWith("RANDOM_")) {
                    try {
                        int length = Integer.parseInt(type.substring(7));
                        return randomString(length);
                    } catch (NumberFormatException e) {
                        return type;
                    }
                }
                return type;
        }
    }

    private String randomString(int length) {
        int leftLimit = 97; // 'a'
        int rightLimit = 122; // 'z'
        return random.ints(leftLimit, rightLimit + 1)
                .limit(length)
                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append)
                .toString();
    }

    public List<String> parseNationalities(String commaSeparated) {
        if (commaSeparated == null || commaSeparated.trim().isEmpty()) return Collections.emptyList();
        return Arrays.stream(commaSeparated.split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .collect(Collectors.toList());
    }

    public List<POJONewDocumentRequest.QuestionAnswer> parseQuestionAnswers(String qaPairs) {
        List<POJONewDocumentRequest.QuestionAnswer> qaList = new ArrayList<>();
        if (qaPairs != null && !qaPairs.trim().isEmpty()) {
            String[] pairs = qaPairs.split(";");
            for (String pair : pairs) {
                String[] qa = pair.split("=", 2);
                if (qa.length == 2) {
                    POJONewDocumentRequest.QuestionAnswer qaObj = new POJONewDocumentRequest.QuestionAnswer();
                    qaObj.setStrQuestion(resolveDynamicText(qa[0].trim()));
                    qaObj.setStrAnswer(resolveDynamicText(qa[1].trim()));
                    qaList.add(qaObj);
                }
            }
        }
        return qaList;
    }

    public String getOrEmpty(Map<String, String> map, String key) {
        return Optional.ofNullable(map.get(key)).orElse("");
    }

    public String resolveId(String input, String resolvedValue) {
        if (input == null || input.trim().isEmpty()) {
            return "";
        }

        switch (input.trim().toUpperCase()) {
            case "EMPTY":
                return "";
            case "NA":
                return null;
            case "NATURAL_PERSON_OBJECT_ID":
            case "CONTAINER_OBJECT_ID":
            case "ADDRESS_OBJECT_ID":
//            case "ADDRESS_OBJECT_ID_CARD":
            case "MONEY_ACCOUNT_OBJECT_ID":
                return resolvedValue;
            default:
                return input;
        }
    }

    public List<String> resolveIdList(String input, String fallbackSingleAddressId, List<String> addressObjectIds) {
        if (input == null || input.trim().isEmpty()) {
            return Collections.emptyList();
        }

        if ("ADDRESS_OBJECT_ID_LIST".equalsIgnoreCase(input.trim())) {
            return addressObjectIds != null ? addressObjectIds : Collections.emptyList();
        }

        // Resolve individual tokens
        return Arrays.stream(input.split(","))
                .map(id -> resolveId(id.trim(), fallbackSingleAddressId))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }

    public void applyBigDecimalField(String rawValue, String fieldName, POJOMoneyAccountRequest account) {
        String normalized = normalize(rawValue);
        if (normalized != null && !normalized.isEmpty()) {
            try {
                BigDecimal parsed = new BigDecimal(normalized);
                switch (fieldName) {
                    case "mailingOffsetDay":
                        account.setMailingOffsetDay(parsed);
                        break;
                    case "mailingOffsetMonth":
                        account.setMailingOffsetMonth(parsed);
                        break;
                    case "minimalNoticeDays":
                        account.setMinimalNoticeDays(parsed);
                        break;
                    default:
                        System.err.println("Unknown field: " + fieldName);
                }
            } catch (NumberFormatException e) {
                System.err.println("Invalid numeric value for " + fieldName + ": " + normalized);
            }
        }
    }

    public void applyBooleanField(String rawValue, String fieldName, POJOMoneyAccountRequest account) {
        String normalized = normalize(rawValue);
        if (normalized != null && !normalized.isEmpty()) {
            boolean parsed = Boolean.parseBoolean(normalized);
            switch (fieldName) {
                case "isMailingPaper":
                    account.setBlnIsMailingPaper(parsed);
                    break;
                default:
                    System.err.println("Unknown boolean field: " + fieldName);
            }
        }
    }

    public void applyBigDecimalField(String rawValue, String fieldName, POJODebitCardRequest card) {
        String normalized = normalize(rawValue);
        if (normalized != null && !normalized.isEmpty()) {
            try {
                BigDecimal parsed = new BigDecimal(normalized);
                switch (fieldName) {
                    case "dailyLimit":
                        card.setBdDailyLimit(parsed);
                        break;
                    default:
                        System.err.println("Unknown field: " + fieldName);
                }
            } catch (NumberFormatException e) {
                System.err.println("Invalid numeric value for " + fieldName + ": " + normalized);
            }
        }
    }

    public String resolveDate(String context, String fieldName, String dateInput) {
        if (dateInput == null || dateInput.trim().isEmpty()) {
            return ""; // Treat null/empty input as empty string
        }

        String input = dateInput.trim().toUpperCase();

        switch (input) {
            case "NA":
                return null;
            case "EMPTY":
                return "";
            case "DEFAULT":
                return getDefaultDateForField(fieldName);
            case "TODAY":
                return LocalDate.now().toString();
            case "PAST":
                return resolvePastDate(context);
            case "FUTURE":
                return resolveFutureDate(context);
            default:
                return input; // Assume valid yyyy-MM-dd format
        }
    }

    private String resolvePastDate(String context) {
        LocalDate today = LocalDate.now();
        if ("WorkRequest".equalsIgnoreCase(context)) {
            return today.minusDays(7).toString();
        } else {
            return today.minusDays(1).toString();
        }
    }

    private String resolveFutureDate(String context) {
        LocalDate today = LocalDate.now();
        if ("WorkRequest".equalsIgnoreCase(context)) {
            return today.plusDays(7).toString();
        } else {
            return today.plusDays(1).toString();
        }
    }

    private String getDefaultDateForField(String fieldName) {
        LocalDate today = LocalDate.now();

        switch (fieldName.toLowerCase()) {
            case "birthdate":
                return today.minusYears(40).toString();
            case "issuedate":
                return today.minusDays(1).toString();
            case "validuntil":
                return today.plusDays(1).toString();
            case "uktaxresidencefromdate":
                return today.minusYears(10).toString();
            default:
                throw new IllegalArgumentException("Unknown date field: " + fieldName);
        }
    }

}

kindly use this
