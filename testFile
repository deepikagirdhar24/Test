package utilities;

import com.aventstack.extentreports.cucumber.adapter.ExtentCucumberAdapter;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.restassured.response.Response;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class JsonHelper {

    private static final ObjectMapper objectMapper = new ObjectMapper();

    private static JsonNode getNodeByPath(JsonNode rootNode, String path) {
        String[] keys = path.split("\\.");
        for (String key : keys) {
            if (rootNode == null) break;
            rootNode = rootNode.path(key);
        }
        return rootNode;
    }

    public static Object extractRawField(Response response, String fieldPath) throws Exception {
        JsonNode rootNode = objectMapper.readTree(response.asString());
        JsonNode node = getNodeByPath(rootNode, fieldPath);
        return node.isMissingNode() || node.isNull() ? null : node;
    }

    public static String extractStringField(Response response, String fieldPath) throws Exception {
        JsonNode rootNode = objectMapper.readTree(response.asString());
        JsonNode node = getNodeByPath(rootNode, fieldPath);
        return node.isMissingNode() || node.isNull() ? null : node.asText();
    }

    public static Boolean extractBooleanField(Response response, String fieldPath) throws Exception {
        JsonNode rootNode = objectMapper.readTree(response.asString());
        JsonNode node = getNodeByPath(rootNode, fieldPath);
        return node.isMissingNode() || node.isNull() ? null : node.asBoolean();
    }

    public static boolean valueExistsInJsonArray(Response response, String jsonPath, String targetValue) throws Exception {
        JsonNode rootNode = objectMapper.readTree(response.asString());
        JsonNode arrayNode = getNodeByPath(rootNode, jsonPath);
        if (arrayNode != null && arrayNode.isArray()) {
            return iterateAndCheckArray(arrayNode, targetValue);
        }
        return false;
    }

    private static boolean iterateAndCheckArray(JsonNode arrayNode, String targetValue) {
        for (JsonNode itemNode : arrayNode) {
            String currentValue = itemNode.asText();
            System.out.println("Checking item: " + currentValue);
            if (targetValue.equals(currentValue)) {
                logMatchFound(currentValue);
                return true;
            }
        }
        return false;
    }

    private static void logMatchFound(String value) {
        System.out.println("Match found: " + value);
        ExtentCucumberAdapter.addTestStepLog("Actual value found: " + value);
    }

    public static List<String> extractListOfStringFieldsFromArray(Response response, String arrayField, String subField) {
        List<Map<String, Object>> itemList = response.jsonPath().getList(arrayField);
        List<String> result = new ArrayList<>();
        for (Map<String, Object> item : itemList) {
            Object value = item.get(subField);
            if (value != null) {
                result.add(value.toString());
            }
        }
        return result;
    }

    /**
     * Extracts a value from a JSON string using the provided path
     *
     * @param jsonResponse The JSON response string
     * @param path The path to the value (dot notation, e.g., "onlineBankingSetup.email")
     * @return The value at the specified path, or null if not found
     */
    public static Object extractValue(String jsonResponse, String path) {
        try {
            String cleanedJson = cleanJsonResponse(jsonResponse);
            JSONObject jsonObject = new JSONObject(cleanedJson);

            String[] pathParts = path.split("\\.");
            JSONObject currentObject = jsonObject;

            for (int i = 0; i < pathParts.length - 1; i++) {
                currentObject = currentObject.getJSONObject(pathParts[i]);
            }

            String finalKey = pathParts[pathParts.length - 1];
            return currentObject.get(finalKey);

        } catch (Exception e) {
            System.err.println("Error extracting JSON value: " + e.getMessage());
            return null;
        }
    }

    public static String extractString(String jsonResponse, String path) {
        Object value = extractValue(jsonResponse, path);
        return value != null ? value.toString() : null;
    }

    public static Boolean extractBoolean(String jsonResponse, String path) {
        Object value = extractValue(jsonResponse, path);
        return value instanceof Boolean ? (Boolean) value : null;
    }

    public static Number extractNumber(String jsonResponse, String path) {
        Object value = extractValue(jsonResponse, path);
        return value instanceof Number ? (Number) value : null;
    }

    private static String cleanJsonResponse(String response) {
        int startIndex = response.indexOf('{');
        int endIndex = response.lastIndexOf('}') + 1;

        if (startIndex >= 0 && endIndex > startIndex) {
            return response.substring(startIndex, endIndex);
        }

        return response;
    }

    public static void validateFieldExistsInArray(Response response, String arrayPath, String fieldName) throws Exception {
        JsonNode rootNode = objectMapper.readTree(response.asString());
        JsonNode arrayNode = rootNode.at(arrayPath); // arrayPath must begin with '/'

        if (!arrayNode.isArray()) {
            throw new Exception("Expected an array at path: " + arrayPath);
        }

        for (JsonNode element : arrayNode) {
            JsonNode fieldNode = element.get(fieldName);
            if (fieldNode == null || fieldNode.asText().isEmpty()) {
                throw new AssertionError("Missing or empty '" + fieldName + "' in one of the elements at: " + arrayPath);
            }
        }

        ExtentCucumberAdapter.addTestStepLog("All elements in array " + arrayPath + " contain a valid '" + fieldName + "'");
    }
}
